# Документирование проекта для понимания его AI

Любой проект (программа, сайт, библиотека и т.д.) должен быть понятен искусственному интеллекту. Какие существуют способы организовать документирование, самодокументированный код и другие подходы, чтобы AI мог по этой документации понимать, что и как реализовано в проекте? Цель — чтобы AI-ассистентам и разработчикам не приходилось анализировать код построчно, а достаточно было прочитать структурированное описание для понимания архитектуры и логики.

Какие подходы используются в настоящее время и какие перспективные новинки существуют в этой области?

---

## Содержание

- [Содержание](#содержание)
- [1. Традиционные подходы к документированию](#1-традиционные-подходы-к-документированию)
	- [1.1. README и архитектурная документация](#11-readme-и-архитектурная-документация)
	- [1.2. Inline-документация](#12-inline-документация)
	- [1.3. Внешняя документация](#13-внешняя-документация)
- [2. Самодокументированный код](#2-самодокументированный-код)
	- [2.1. Принципы](#21-принципы)
	- [2.2. Структурирование](#22-структурирование)
- [3. Специфичные для AI подходы](#3-специфичные-для-ai-подходы)
	- [3.1. Структурированные форматы для AI](#31-структурированные-форматы-для-ai)
	- [3.2. Семантические аннотации](#32-семантические-аннотации)
	- [3.3. AI-ориентированные файлы](#33-ai-ориентированные-файлы)
- [4. Современные инструменты и стандарты](#4-современные-инструменты-и-стандарты)
	- [4.1. Генерация документации](#41-генерация-документации)
	- [4.2. Стандарты документирования](#42-стандарты-документирования)
	- [4.3. Инструменты анализа кода](#43-инструменты-анализа-кода)
- [5. Перспективные новинки](#5-перспективные-новинки)
	- [5.1. AI-native документирование](#51-ai-native-документирование)
	- [5.2. Структурированные форматы](#52-структурированные-форматы)
	- [5.3. Контекстные системы](#53-контекстные-системы)
	- [5.4. Метаданные и аннотации](#54-метаданные-и-аннотации)
	- [5.5. Git-native документирование (Project Cognition Layer)](#55-git-native-документирование-project-cognition-layer)
		- [Проблема векторных БД](#проблема-векторных-бд)
		- [Решение: Обогащенные коммиты](#решение-обогащенные-коммиты)
		- [Преимущества подхода](#преимущества-подхода)
		- [Механизмы](#механизмы)
- [6. Рекомендации по организации](#6-рекомендации-по-организации)
	- [6.1. Иерархия документации](#61-иерархия-документации)
	- [6.2. Принципы для AI-понимания](#62-принципы-для-ai-понимания)
	- [6.3. Чеклист документирования](#63-чеклист-документирования)
- [7. Выводы](#7-выводы)

---

## 1. Традиционные подходы к документированию

### 1.1. README и архитектурная документация

- **README.md** — точка входа для понимания проекта
  - Описание назначения проекта
  - Быстрый старт
  - Структура проекта
  - Основные зависимости
- **ARCHITECTURE.md** — описание архитектурных решений
  - Диаграммы компонентов
  - Паттерны проектирования
  - Потоки данных
- **CONTRIBUTING.md** — правила разработки

### 1.2. Inline-документация

- **Docstrings** (Python, JavaScript JSDoc, JavaDoc)
- **Комментарии** в коде для объяснения сложной логики
- **Type hints** и аннотации типов как форма документации

### 1.3. Внешняя документация

- **API документация** (OpenAPI/Swagger, GraphQL схемы)
- **Диаграммы** (UML, Mermaid, PlantUML)
- **Wiki** и отдельные документы

---

## 2. Самодокументированный код

### 2.1. Принципы

- **Понятные имена** переменных, функций, классов
- **Малая цикломатическая сложность** функций
- **Единственная ответственность** (SRP)
- **Явное лучше неявного**

### 2.2. Структурирование

- **Модульная архитектура** с четкими границами
- **Конвенции именования** (camelCase, snake_case, kebab-case)
- **Организация файлов** по функциональности или слоям

---

## 3. Специфичные для AI подходы

### 3.1. Структурированные форматы для AI

- **Markdown с четкой структурой** — легко парсится AI
- **YAML/JSON конфигурации** с описаниями полей
- **Схемы данных** (JSON Schema, TypeScript типы)

### 3.2. Семантические аннотации

- **Комментарии с метаданными** о назначении кода
- **Теги и категории** для группировки функциональности
- **Описания intent** (намерений) перед сложными блоками

### 3.3. AI-ориентированные файлы

- **`.cursorrules`** или **`AGENTS.md`** — правила для AI-ассистентов
- **`docs/`** с структурированной документацией
- **Примеры использования** в виде кода или тестов

---

## 4. Современные инструменты и стандарты

### 4.1. Генерация документации

- **Docusaurus**, **VitePress**, **MkDocs** — статическая генерация
- **TypeDoc**, **Sphinx**, **JSDoc** — из кода
- **Copilot Docs**, **Codeium** — AI-ассистенты для документации

### 4.2. Стандарты документирования

- **OpenAPI 3.0** для REST API
- **AsyncAPI** для событийно-ориентированных систем
- **Architecture Decision Records (ADR)** — документирование решений

### 4.3. Инструменты анализа кода

- **CodeQL**, **Sourcegraph** — семантический поиск
- **Tree-sitter** — парсинг кода для анализа
- **LSP (Language Server Protocol)** — понимание структуры проекта

---

## 5. Перспективные новинки

### 5.1. AI-native документирование

- **Embeddings и векторные БД** — семантический поиск по коду
- **Автогенерация документации** через LLM (GitHub Copilot, Cursor)
- **Интерактивные AI-агенты** для ответов на вопросы о проекте

### 5.2. Структурированные форматы

- **C4 Model** — иерархическое описание архитектуры
- **Structurizr** — диаграммы как код
- **Mermaid в Markdown** — диаграммы, читаемые AI

### 5.3. Контекстные системы

- **Context7**, **Continue.dev** — интеграция документации в AI-контекст
- **MCP (Model Context Protocol)** — стандартизация доступа к контексту
- **RAG (Retrieval-Augmented Generation)** — обогащение контекста AI

### 5.4. Метаданные и аннотации

- **JSDoc с расширенными тегами** для AI
- **TypeScript satisfies** для проверки типов и документации
- **Комментарии в формате Markdown** внутри кода

### 5.5. Git-native документирование (Project Cognition Layer)

**Концепция:** Использование Git как хранилища не только кода, но и понимания проекта через когнитивный слой.

#### Проблема векторных БД

Традиционный подход с embeddings и векторными БД основан на **семантическом сходстве** — вероятностном поиске, где нет гарантии найти именно нужный код. Векторный поиск может пропустить релевантные фрагменты или вернуть неверные результаты.

#### Решение: Обогащенные коммиты

**Принцип работы:**

1. **Атомарная связка:** Каждое изменение кода сопровождается файлом описания в `.context/evolution/`, который коммитится вместе с кодом
2. **Жесткая связь:** Описание решения задачи жестко привязано к конкретным строкам кода через хэш коммита
3. **Семантическая летопись:** История проекта превращается в базу знаний с ссылочной целостностью

**Структура когнитивного слоя:**

```
.context/
├── evolution/              # История архитектурных решений
│   └── feature_refactor.md # Описание изменений с привязкой к коммиту
├── knowledge_map.json      # Граф зависимостей модулей
└── confidence_scores.json  # Метрики актуальности знаний
```

#### Преимущества подхода

- **Точность:** Жесткая связь "описание ↔ код" вместо вероятностного поиска
- **Исторический контекст:** Видно не только результат, но и процесс принятия решений
- **Командная синхронизация:** Контекст передается через Git между разработчиками
- **Прозрачность:** Читаемые файлы вместо черного ящика векторной БД

#### Механизмы

1. **Confidence Score** — метрика актуальности знаний AI

   - Отслеживание изменений файлов с момента последнего анализа
   - Автоматическое помечание устаревших знаний как недостоверных

2. **Context Evolution Tracker** — журнал архитектурных решений

   - Описание бизнес-задач и причин принятых решений
   - Ссылки на конкретные файлы и коммиты

3. **Динамический граф знаний** — структура зависимостей модулей
   - Инкрементальное обновление только измененных частей
   - Визуализация "горячих точек" проекта

**Источник:** [Project Cognition Layer: Почему AI-агенту нужна не только векторная БД, а Git](https://habr.com/ru/articles/970560/)

---

## 6. Рекомендации по организации

### 6.1. Иерархия документации

**Традиционная структура:**

```
docs/
├── README.md              # Обзор проекта
├── architecture/          # Архитектурные решения
├── api/                   # API документация
├── guides/                # Руководства
└── examples/              # Примеры использования
```

**Git-native структура (Project Cognition Layer):**

```
.context/                  # Когнитивный слой проекта
├── evolution/             # История архитектурных решений
│   └── feature_name.md    # Описание изменений с привязкой к коммиту
├── knowledge_map.json     # Граф зависимостей модулей
└── confidence_scores.json # Метрики актуальности знаний AI

docs/                      # Статическая документация
├── README.md
├── architecture/
├── api/
├── guides/
└── examples/
```

### 6.2. Принципы для AI-понимания

1. **Явность** — явно описывать намерения
2. **Структурированность** — четкая иерархия и навигация
3. **Примеры** — конкретные use cases
4. **Актуальность** — синхронизация с кодом
5. **Метаданные** — теги, категории, связи

### 6.3. Чеклист документирования

- [ ] README с описанием проекта
- [ ] Архитектурная документация
- [ ] API документация (если есть API)
- [ ] Примеры использования
- [ ] Описание зависимостей и их назначения
- [ ] Правила разработки (CONTRIBUTING)
- [ ] История изменений (CHANGELOG)
- [ ] Правила для AI-ассистентов (если используются)

---

## 7. Выводы

**Ключевые принципы:**

- Комбинация традиционных и AI-ориентированных подходов
- Структурированность и явность описаний
- Актуальность документации (синхронизация с кодом)
- Использование современных инструментов генерации и анализа

**Тренды:**

- Автоматизация генерации документации через AI
- Семантический поиск по коду и документации (векторные БД)
- **Git-native документирование** — использование Git как хранилища понимания проекта
- Стандартизация форматов для AI-понимания (MCP, Context7)
- Интеграция документации в workflow разработки
- Отслеживание эволюции архитектурных решений параллельно с кодом
