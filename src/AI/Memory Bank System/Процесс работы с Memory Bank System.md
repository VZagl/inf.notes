# Процесс работы с Memory Bank System

## Содержание

- [Содержание](#содержание)
- [Введение](#введение)
- [Базовые сценарии инициализации](#базовые-сценарии-инициализации)
  - [2.1. Инициализация нового проекта](#21-инициализация-нового-проекта)
  - [2.2. Интеграция в существующий проект](#22-интеграция-в-существующий-проект)
- [Модульные процессы](#модульные-процессы)
  - [3.1. Добавление мультиязычности (i18n)](#31-добавление-мультиязычности-i18n)
  - [3.2. Рефакторинг легаси кода](#32-рефакторинг-легаси-кода)
  - [3.3. Добавление новой функциональности](#33-добавление-новой-функциональности)
- [Комбинированные сценарии](#комбинированные-сценарии)
- [Рекомендации и лучшие практики](#рекомендации-и-лучшие-практики)

---

## Введение

Данный документ описывает практические процессы работы с Memory Bank System на примере приложения "TO-DO list" (React 19 + TypeScript + Tailwind CSS).

### Модульный подход

Документ структурирован по модульному принципу:

- **Базовые сценарии** описывают инициализацию системы в проекте (новый или существующий)
- **Модульные процессы** — независимые процессы, которые можно применять в любом проекте независимо от того, был ли он создан с Memory Bank или нет
- **Комбинированные сценарии** показывают, как объединять различные процессы

### Как использовать этот документ

1. Если вы начинаете новый проект — начните с раздела [2.1. Инициализация нового проекта](#21-инициализация-нового-проекта)
   - Выполните команду `/van [описание проекта]` для инициализации
2. Если интегрируете систему в существующий проект — перейдите к разделу [2.2. Интеграция в существующий проект](#22-интеграция-в-существующий-проект)
   - Выполните команду `/van [описание задачи интеграции]` для начала работы
3. Для конкретных задач (локализация, рефакторинг и т.д.) используйте соответствующие модульные процессы из раздела [3. Модульные процессы](#модульные-процессы)
   - Каждый процесс содержит явные указания на команды, которые нужно выполнить

### Работа с чатами и контекстом

**Рекомендуемая практика:** Создавайте новый чат для каждой команды Memory Bank System, чтобы очистить контекст и обеспечить фокусировку на текущей фазе.

**Структура чатов:**

```
Чат 1: /van [описание задачи]
  ↓
Чат 2: /plan
  ↓
Чат 3: /creative
       ↓ (в том же чате!)
       VAN QA  ← НЕ создавать новый чат!
  ↓
Чат 4: /build
  ↓
Чат 5: /reflect
  ↓
Чат 6: /archive
```

**Важное исключение:** **VAN QA выполняется в том же чате, что и `/creative`**, потому что:

- VAN QA нужен доступ к результатам CREATIVE фазы
- Это валидационная проверка, а не отдельная фаза
- После валидации система продолжает workflow в том же контексте
- При неудачной валидации исправьте проблемы и запустите VAN QA повторно в том же чате

### Использование Context7 MCP-сервера

**Context7** — это MCP-сервер, который предоставляет доступ к актуальной документации библиотек и фреймворков. Если у вас настроен Context7, рекомендуется указывать это в команде `/van` для автоматического использования на всех этапах разработки.

**Преимущества использования Context7:**

- Доступ к актуальной документации библиотек
- Проверка совместимости версий
- Использование современных API и паттернов
- Автоматическое применение на всех этапах (планирование, проектирование, реализация)

**Как использовать:**

Добавьте указание на Context7 в описание задачи при инициализации:

```
/van Создать TO-DO приложение на React 19 + TypeScript. Используй Context7 MCP-сервер.
```

После этого Memory Bank System будет автоматически использовать Context7 на всех этапах:

- **`/plan`** — при планировании технологий и зависимостей
- **`/creative`** — при проектировании архитектуры и выборе паттернов
- **`VAN QA`** — при проверке актуальности зависимостей
- **`/build`** — при генерации кода
- **`/reflect`** — при анализе использованных технологий

**Примечание:** Если Context7 не настроен в вашем проекте, ИИ будет использовать свои базовые знания. Для настройки Context7 обратитесь к документации MCP-серверов.

### Пример проекта

В качестве примера используется приложение "TO-DO list":

- **Технологии:** React 19, TypeScript, Tailwind CSS
- **Исходное состояние:** Приложение на русском языке
- **Задача:** Добавление мультиязычности (i18n)

### Команды Memory Bank System

Memory Bank System использует следующие команды Cursor 2.0:

- **`/van [описание задачи]`** — Инициализация задачи или проекта

  - Принимает описание задачи в качестве параметра
  - Создает структуру Memory Bank и анализирует проект
  - Пример: `/van Создать TO-DO приложение на React`
  - **Рекомендация:** Если у вас настроен Context7 MCP-сервер, укажите это в описании для использования актуальной документации на всех этапах
  - Пример с Context7: `/van Создать TO-DO приложение на React 19 + TypeScript. Используй Context7 MCP-сервер.`

- **`/plan`** — Планирование задач

  - Работает с текущей задачей из Memory Bank
  - Создает структурированный план реализации
  - Используется без параметров

- **`/creative`** — Проектирование и креативные решения

  - Проектирует архитектуру и дизайн для текущей задачи
  - Генерирует идеи и концепции
  - Используется без параметров

- **`VAN QA`** — Техническая валидация (вводится как текст, не команда)

  - Выполняет техническую валидацию перед реализацией
  - Проверяет зависимости, конфигурацию, окружение и минимальную сборку
  - Блокирует переход к BUILD при наличии проблем
  - Используется после `/creative` и перед `/build`

- **`/build`** — Реализация

  - Выполняет реализацию текущей задачи
  - Создает код согласно плану и архитектуре
  - Используется без параметров
  - **Требует успешного прохождения VAN QA**

- **`/reflect`** — Рефлексия и анализ

  - Анализирует выполненную работу
  - Выявляет проблемы и улучшения
  - Используется без параметров

- **`/archive`** — Архивация
  - Сохраняет завершенную задачу в архив
  - Создает финальную документацию
  - Используется без параметров

**Последовательность использования:**

```
/van [описание задачи] → /plan → /creative → VAN QA → /build → /reflect → /archive
```

### Детальное описание стадии VAN QA

**VAN QA** — это критически важная стадия **технической валидации**, которая выполняется после CREATIVE и перед BUILD. Она гарантирует, что все технические требования выполнены перед началом реализации.

**Схема работы с чатами:**

```text
╔═════════════════════════════════════════════════════╗
║ Чат 3: /creative                                    ║
║                                                     ║
║ 1. Проектирование архитектуры                       ║
║ 2. Создание дизайн-решений                          ║
║ 3. Сохранение в memory-bank/creative/               ║
║                                                     ║
║ ┌───────────────────────────────────────────────┐   ║
║ │ VAN QA  ← Выполняется в том же чате!          │   ║
║ │                                               │   ║
║ │ • Читает результаты CREATIVE                  │   ║
║ │ • Проверяет зависимости                       │   ║
║ │ • Валидирует конфигурацию                     │   ║
║ │ • Тестирует окружение                         │   ║
║ │ • Запускает минимальную сборку                │   ║
║ │                                               │   ║
║ │ Результат: ✅ SUCCESS или ❌ FAILURE         │   ║
║ └───────────────────────────────────────────────┘   ║
║                                                     ║
║ Если FAILURE → исправить → VAN QA снова             ║
╚═════════════════════════════════════════════════════╝
                       ↓
          Если SUCCESS: создать новый чат
                       ↓
╔═════════════════════════════════════════════════════╗
║ Чат 4: /build                                       ║
║                                                     ║
║ Реализация кода                                     ║
╚═════════════════════════════════════════════════════╝
```

#### Цель VAN QA

Стадия VAN QA проверяет готовность проекта к реализации:

- Все необходимые зависимости установлены и совместимы
- Конфигурационные файлы корректны
- Окружение готово для разработки
- Минимальная сборка проекта работает

#### Процесс валидации

VAN QA выполняет **четыре ключевые проверки** в последовательном порядке:

1. **Проверка зависимостей (Dependency Verification)**

   - Проверка наличия всех необходимых пакетов
   - Проверка версий зависимостей
   - Выявление конфликтов версий

2. **Валидация конфигурации (Configuration Validation)**

   - Проверка корректности файлов конфигурации
   - Валидация настроек проекта
   - Проверка путей и переменных окружения

3. **Проверка окружения (Environment Validation)**

   - Проверка настройки среды разработки
   - Валидация необходимых инструментов
   - Проверка системных требований

4. **Минимальный тест сборки (Minimal Build Test)**
   - Проверка базовой функциональности
   - Тест минимальной сборки проекта
   - Выявление критических ошибок до начала разработки

#### Как использовать VAN QA

После завершения стадии CREATIVE:

1. **В том же чате**, где выполнялась `/creative`, введите текст **"VAN QA"** (без слэша, это не команда)
2. Система автоматически запустит все 4 проверки
3. По результатам вы получите:
   - **✅ SUCCESS** — все проверки пройдены, можно переходить к `/build` в новом чате
   - **❌ FAILURE** — есть проблемы, которые необходимо исправить

**Важно:** VAN QA выполняется **в том же чате, что и `/creative`**, потому что:

- VAN QA читает и анализирует результаты CREATIVE фазы
- Сохраняется контекст проектных решений
- После валидации система продолжает workflow в том же контексте
- VAN QA — это не отдельная фаза, а валидационная проверка перед BUILD

#### Блокировка BUILD режима

**Важно:** Если VAN QA не пройдена успешно, система **заблокирует доступ** к режиму `/build`. Это предотвращает ситуации, когда вы начинаете писать код при неготовом окружении.

**При неудачной валидации:**

1. Исправьте выявленные проблемы (в том же чате или отдельно)
2. Вернитесь в чат с `/creative`
3. Введите "VAN QA" снова для повторной валидации
4. Только после успешной валидации (✅ SUCCESS) создавайте новый чат для `/build`

#### Зачем это нужно

VAN QA экономит время, предотвращая типичные проблемы:

- Обнаружение отсутствующих пакетов до начала кодирования
- Выявление ошибок конфигурации на ранней стадии
- Проверка готовности окружения перед разработкой
- Гарантия работоспособности базовой сборки

---

## Базовые сценарии инициализации

### 2.1. Инициализация нового проекта

Этот сценарий применяется, когда вы создаете новый проект с нуля или используете пустой бойлерплейт и хотите сразу начать работу с Memory Bank System.

#### Пример: Создание нового TO-DO приложения

**Исходная ситуация:**

- Пустая директория или инициализированный проект (например, через `create-react-app` или Vite)
- React 19, TypeScript, Tailwind CSS уже настроены или будут настроены
- Memory Bank System еще не интегрирована

#### Шаг 1: Подготовка проекта

**Команда:** `/van [описание задачи]`

**Пример использования:**

```
/van Создать TO-DO приложение на React 19 с TypeScript и Tailwind CSS
```

**Пример с Context7 (рекомендуется, если настроен):**

```
/van Создать TO-DO приложение на React 19 с TypeScript и Tailwind CSS. Используй Context7 MCP-сервер для актуальной документации.
```

**Действия:**

1. **Установка Memory Bank System:**

   - Копирование директории `.cursor/` с командами и правилами
   - Копирование файла `.cursorindexingignore`
   - Настройка Custom Modes в Cursor

2. **Создание структуры Memory Bank:**

   - Создание директории `memory-bank/`
   - Инициализация всех необходимых файлов:
     - `projectbrief.md`
     - `productContext.md`
     - `activeContext.md`
     - `systemPatterns.md`
     - `techContext.md`
     - `progress.md`
     - `tasks.md`
     - `memory_bank_instructions.md`
   - Создание поддиректорий `creative/` и `archive/`

3. **Выполнение команды `/van`:**
   - AI определяет платформу проекта (веб-приложение)
   - Оценивает сложность (средняя для TO-DO приложения)
   - Заполняет базовые файлы Memory Bank с информацией о проекте

**Результат:**

- Структура Memory Bank создана и заполнена базовой информацией
- Проект готов к планированию

#### Шаг 2: Планирование проекта

**Команда:** `/plan`

**Действия:**

1. **Анализ требований:**

   - Определение функциональности TO-DO приложения
   - Выявление основных компонентов и их взаимодействия
   - Оценка сложности каждой задачи

2. **Создание структуры задач:**

   - Разбиение проекта на этапы:
     - Настройка базовой структуры проекта
     - Создание компонентов (TodoList, TodoItem, AddTodoForm)
     - Реализация логики управления состоянием
     - Стилизация с Tailwind CSS
     - Добавление функциональности (добавление, удаление, отметка выполнения)
   - Определение приоритетов и зависимостей между задачами

3. **Заполнение файлов Memory Bank:**
   - `tasks.md`: детальный список всех задач с приоритетами
   - `progress.md`: начальное состояние проекта (0% выполнено)
   - `productContext.md`: описание продукта и его целей
   - `techContext.md`: используемые технологии и их версии

**Результат:**

- Четкий план работы с приоритизированными задачами
- Понимание архитектуры будущего приложения

#### Шаг 3: Проектирование архитектуры

**Команда:** `/creative`

**Действия:**

1. **Проектирование структуры компонентов:**

   - Определение иерархии компонентов
   - Планирование пропсов и состояний
   - Выбор паттернов управления состоянием (локальное состояние, Context API, или Zustand)

2. **Проектирование UI/UX:**

   - Создание концепции дизайна интерфейса
   - Планирование расположения элементов
   - Определение цветовой схемы и стилей

3. **Сохранение решений:**
   - Архитектурные решения сохраняются в `memory-bank/creative/architecture.md`
   - Дизайн-концепции в `memory-bank/creative/design.md`

**Результат:**

- Проектные решения готовы к валидации
- Архитектура спроектирована и задокументирована

#### Шаг 4: Техническая валидация

**Команда:** Введите текст **"VAN QA"**

**Действия:**

1. **Автоматическая проверка зависимостей:**

   - Система проверяет наличие необходимых пакетов
   - Валидирует версии зависимостей
   - Выявляет конфликты

2. **Валидация конфигурации:**

   - Проверка файлов конфигурации проекта
   - Валидация настроек инструментов разработки
   - Проверка путей и переменных окружения

3. **Проверка окружения:**

   - Валидация среды разработки
   - Проверка необходимых инструментов
   - Проверка системных требований

4. **Минимальный тест сборки:**
   - Запуск базовой сборки проекта
   - Проверка работоспособности
   - Выявление критических ошибок

**Результат:**

- Техническая готовность проекта подтверждена
- Все проблемы выявлены и исправлены до начала кодирования
- Разрешён переход к реализации

#### Шаг 5: Реализация

**Команда:** `/build`

**Действия:**

1. **Систематическая реализация задач:**

   - Выполнение задач из `tasks.md` по приоритету
   - Создание компонентов согласно спроектированной архитектуре
   - Написание кода с учетом паттернов из `systemPatterns.md`

2. **Обновление Memory Bank в процессе работы:**

   - `activeContext.md`: обновляется с текущим фокусом работы (например, "Работа над компонентом TodoItem")
   - `progress.md`: регулярно обновляется с процентом выполнения
   - `systemPatterns.md`: добавляются новые паттерны по мере их использования

3. **Итеративный процесс:**
   - Реализация компонента
   - Тестирование функциональности
   - Обновление прогресса
   - Переход к следующей задаче

**Результат:**

- Реализованное приложение со всей запланированной функциональностью
- Актуальное состояние проекта отражено в Memory Bank

#### Шаг 6: Рефлексия

**Команда:** `/reflect`

**Действия:**

1. **Анализ выполненной работы:**

   - Оценка качества реализации
   - Выявление проблем и узких мест
   - Анализ соответствия реализации изначальному плану

2. **Документирование уроков:**

   - Извлеченные уроки сохраняются в `systemPatterns.md`
   - Рекомендации для будущих итераций записываются в `activeContext.md`

3. **Оценка процесса:**
   - Анализ эффективности использования Memory Bank
   - Выявление улучшений в процессе работы

**Результат:**

- Проанализированная работа с выводами и улучшениями
- Накопленный опыт для будущих проектов

#### Шаг 7: Архивация

**Команда:** `/archive`

**Действия:**

1. **Финальное документирование:**

   - Создание полной документации проекта
   - Описание архитектуры и принятых решений
   - Инструкции по запуску и использованию

2. **Архивация завершенных задач:**

   - Перемещение завершенных задач в `archive/`
   - Сохранение истории разработки

3. **Подготовка к новым задачам:**
   - Очистка активных файлов для новых задач
   - Сохранение финального состояния проекта

**Результат:**

- Завершенный проект с полной документацией
- Готовность к добавлению новых функций или началу нового проекта

---

### 2.2. Интеграция в существующий проект

Этот сценарий применяется, когда у вас уже есть работающий проект с легаси кодом, и вы хотите интегрировать Memory Bank System для улучшения процесса разработки.

#### Пример: Интеграция в существующее TO-DO приложение

**Исходная ситуация:**

- Существующее TO-DO приложение на React 19 + TypeScript + Tailwind CSS
- Приложение написано на русском языке
- Код может содержать легаси-паттерны и устаревшие подходы
- Документация отсутствует или устарела
- Memory Bank System еще не интегрирована

#### Шаг 1: Резервное копирование и подготовка

**Команда:** `/van [описание задачи]`

**Пример использования:**

```
/van Интегрировать Memory Bank System в существующее TO-DO приложение
```

**Пример с Context7 (рекомендуется, если настроен):**

```
/van Интегрировать Memory Bank System в существующее TO-DO приложение. Используй Context7 MCP-сервер для проверки актуальности зависимостей.
```

**Действия:**

1. **Резервное копирование:**

   - Создание коммита в Git с текущим состоянием проекта
   - Или создание полной копии проекта

2. **Установка Memory Bank System:**

   - Копирование директории `.cursor/` с командами и правилами
   - Копирование файла `.cursorindexingignore`
   - Настройка Custom Modes в Cursor

3. **Создание структуры Memory Bank:**

   - Создание директории `memory-bank/`
   - Инициализация всех необходимых файлов
   - Создание поддиректорий `creative/` и `archive/`

4. **Выполнение команды `/van`:**
   - AI анализирует существующий проект
   - Определяет используемые технологии и их версии
   - Оценивает сложность и структуру проекта
   - Заполняет базовые файлы Memory Bank

**Результат:**

- Структура Memory Bank создана
- Базовое понимание проекта зафиксировано в Memory Bank

#### Шаг 2: Анализ и миграция информации

**Команда:** `/plan`

**Действия:**

1. **Анализ существующего проекта:**

   - AI изучает структуру проекта
   - Анализирует компоненты и их взаимодействие
   - Выявляет архитектурные паттерны
   - Определяет используемые библиотеки и зависимости

2. **Миграция существующей информации:**

   - Если есть README.md — информация переносится в `projectbrief.md` и `productContext.md`
   - Технологии и версии записываются в `techContext.md`
   - Существующая архитектура документируется в `systemPatterns.md`
   - Текущие задачи (если есть) переносятся в `tasks.md`

3. **Создание плана интеграции:**
   - Определение приоритетов работы с существующим кодом
   - Планирование рефакторинга (если необходимо)
   - Составление списка задач для улучшения проекта

**Результат:**

- Вся существующая информация о проекте структурирована в Memory Bank
- Создан план дальнейшей работы

#### Шаг 3: Документирование текущего состояния

**Команда:** `/reflect`

**Действия:**

1. **Анализ текущего состояния:**

   - Документирование архитектуры существующего кода
   - Выявление используемых паттернов (даже если они устаревшие)
   - Фиксация текущих проблем и технического долга

2. **Создание базы знаний:**
   - Сохранение понимания легаси-кода в `systemPatterns.md`
   - Документирование особенностей проекта в `activeContext.md`
   - Запись известных проблем и ограничений

**Результат:**

- Текущее состояние проекта полностью задокументировано
- Создана база знаний для дальнейшей работы

#### Шаг 4: Планирование улучшений

**Команда:** `/plan`

**Действия:**

1. **Определение приоритетов:**

   - Выявление критических проблем, требующих немедленного решения
   - Определение задач для улучшения кодовой базы
   - Планирование новых функций (если необходимо)

2. **Создание дорожной карты:**
   - Разбиение работы на этапы
   - Определение зависимостей между задачами
   - Оценка сложности и времени выполнения

**Результат:**

- Четкий план улучшений проекта
- Приоритизированный список задач

#### Шаг 5: Валидация перед изменениями (опционально)

**Команда:** Введите текст **"VAN QA"**

Для существующих проектов рекомендуется провести техническую валидацию перед началом значительных изменений:

**Действия:**

1. **Проверка текущего состояния:**

   - Валидация существующих зависимостей
   - Проверка конфигурации проекта
   - Оценка готовности окружения

2. **Выявление проблем:**
   - Обнаружение устаревших зависимостей
   - Выявление конфликтов конфигурации
   - Определение необходимых обновлений

**Результат:**

- Понимание текущего технического состояния
- Список проблем, требующих решения
- Готовность к внесению изменений

#### Особенности работы с существующим проектом

**Отличия от нового проекта:**

1. **Больше контекста:**

   - Необходимо понимать существующий код перед изменениями
   - Memory Bank помогает сохранять это понимание между сессиями

2. **Постепенная миграция:**

   - Изменения вносятся постепенно, не нарушая работу приложения
   - Каждое изменение документируется в Memory Bank

3. **Сохранение истории:**

   - Важно документировать, почему код написан именно так
   - Memory Bank помогает сохранить контекст решений

4. **Валидация на каждом этапе:**
   - Рекомендуется использовать VAN QA перед значительными изменениями
   - Проверка готовности окружения перед рефакторингом
   - Валидация после внесения изменений

**Преимущества использования Memory Bank:**

- Сохранение контекста между сессиями работы
- Структурированное документирование изменений
- Возможность отслеживать прогресс рефакторинга
- База знаний для новых участников проекта
- Контроль технической готовности на каждом этапе

---

## Модульные процессы

### 3.1. Добавление мультиязычности (i18n)

Этот модульный процесс применяется независимо от того, был ли проект создан с Memory Bank или нет. Он описывает добавление мультиязычности в существующее приложение.

#### Контекст задачи

**Исходная ситуация:**

- Существующее TO-DO приложение на React 19 + TypeScript + Tailwind CSS
- Все тексты в приложении на русском языке (хардкодные строки)
- Необходимо добавить поддержку нескольких языков (например, русский и английский)
- Приложение может быть как новым (созданным с Memory Bank), так и существующим (легаси)

#### Шаг 1: Планирование

**Команда:** `/plan`

**Действия:**

1. **Анализ существующего кода:**

   - AI анализирует все компоненты приложения
   - Выявляет все хардкодные текстовые строки на русском языке
   - Подсчитывает количество строк для перевода
   - Определяет структуру компонентов и их взаимодействие

2. **Выбор библиотеки локализации:**

   - Оценка вариантов (react-i18next, react-intl, next-intl и т.д.)
   - Выбор наиболее подходящей библиотеки для проекта
   - Определение необходимых зависимостей

3. **Планирование структуры переводов:**

   - Определение структуры файлов переводов (по доменам, компонентам или плоская структура)
   - Планирование ключей локализации
   - Определение поддерживаемых языков

4. **Создание плана миграции:**
   - Разбиение работы на этапы:
     - Установка зависимостей
     - Настройка конфигурации i18n
     - Рефакторинг компонентов (по приоритету)
     - Создание файлов переводов
     - Добавление переключателя языка
     - Тестирование локализации
   - Определение приоритетов компонентов для рефакторинга
   - Оценка сложности и времени выполнения

**Результат:**

- Детальный план работы записан в `memory-bank/tasks.md`
- Оценка сложности и времени в `memory-bank/progress.md`
- Выбранная библиотека и структура документированы в `memory-bank/techContext.md`

#### Шаг 2: Проектирование

**Команда:** `/creative`

**Действия:**

1. **Проектирование архитектуры локализации:**

   - Определение структуры файлов переводов
   - Проектирование системы ключей (именование, группировка)
   - Планирование механизма определения языка пользователя
   - Проектирование переключателя языка в UI

2. **Проектирование процесса миграции:**

   - Определение порядка рефакторинга компонентов
   - Планирование стратегии работы с существующим кодом
   - Проектирование тестирования локализации

3. **Создание схем и документации:**
   - Архитектурное решение сохраняется в `memory-bank/creative/i18n-architecture.md`
   - Структура файлов переводов документируется
   - Схема миграции компонентов создается

**Результат:**

- Архитектура системы локализации спроектирована
- Процесс миграции определен и задокументирован
- Готовность к валидации

#### Шаг 3: Валидация технических требований

**Команда:** Введите текст **"VAN QA"**

**Действия:**

1. **Проверка библиотек локализации:**

   - Валидация установки выбранной библиотеки (react-i18next или другой)
   - Проверка совместимости версий
   - Выявление потенциальных конфликтов зависимостей

2. **Валидация конфигурации i18n:**

   - Проверка корректности настроек локализации
   - Валидация структуры файлов переводов
   - Проверка доступности языковых ресурсов

3. **Проверка окружения:**

   - Валидация поддержки выбранных языков
   - Проверка кодировки файлов
   - Тест базовой функциональности переключения языков

**Результат:**

- Техническая готовность к реализации локализации подтверждена
- Все зависимости проверены и готовы к использованию
- Конфигурация валидирована

#### Шаг 4: Реализация

**Команда:** `/build`

**Действия:**

1. **Установка зависимостей:**

   - Установка выбранной библиотеки локализации (например, react-i18next)
   - Установка дополнительных зависимостей при необходимости

2. **Настройка конфигурации i18n:**

   - Создание конфигурационного файла i18n
   - Настройка провайдера i18n в корневом компоненте приложения
   - Определение языка по умолчанию и механизма его определения

3. **Создание структуры файлов переводов:**

   - Создание директории для переводов (например, `locales/`)
   - Создание файлов переводов для каждого языка (ru.json, en.json)
   - Инициализация структуры ключей

4. **Рефакторинг компонентов:**

   - Систематическая замена хардкодных строк на вызовы функции перевода
   - Обновление компонентов по приоритету (от наиболее важных к менее важным)
   - Добавление хука `useTranslation` в компоненты
   - Замена строк на ключи локализации

5. **Создание файлов переводов:**

   - Перевод всех строк на поддерживаемые языки
   - Проверка полноты переводов
   - Валидация ключей

6. **Добавление переключателя языка:**

   - Создание компонента переключателя языка
   - Интеграция в UI приложения
   - Тестирование переключения языков

7. **Обновление Memory Bank в процессе работы:**
   - `activeContext.md`: обновляется с текущим компонентом в работе
   - `progress.md`: регулярно обновляется с процентом отрефакторенных компонентов
   - `systemPatterns.md`: добавляется паттерн использования i18n

**Результат:**

- Все компоненты отрефакторены для поддержки локализации
- Файлы переводов созданы и заполнены
- Переключатель языка добавлен и работает
- Приложение поддерживает несколько языков

#### Шаг 5: Рефлексия

**Команда:** `/reflect`

**Действия:**

1. **Анализ выполненной работы:**

   - Проверка покрытия всех строк переводами
   - Оценка качества структуры ключей локализации
   - Выявление проблем в процессе миграции
   - Анализ соответствия реализации изначальному плану

2. **Выявление проблем и улучшений:**

   - Документирование найденных проблем
   - Определение областей для улучшения
   - Выявление паттернов, которые можно улучшить

3. **Документирование уроков:**

   - Извлеченные уроки сохраняются в `memory-bank/systemPatterns.md`
   - Рекомендации для будущих компонентов записываются в `memory-bank/activeContext.md`
   - Лучшие практики использования i18n документируются

4. **Оценка процесса:**
   - Анализ эффективности процесса миграции
   - Выявление улучшений в подходе к локализации

**Результат:**

- Проанализированная работа с выводами и улучшениями
- Накопленный опыт для будущих задач локализации
- Документированные паттерны и лучшие практики

#### Особенности процесса

**Работа с существующим кодом:**

- Процесс не требует полной переработки приложения
- Изменения вносятся постепенно, компонент за компонентом
- Существующая функциональность не нарушается

**Сохранение контекста:**

- Memory Bank помогает отслеживать прогресс рефакторинга
- Контекст работы сохраняется между сессиями
- Легко вернуться к работе после перерыва

**Гибкость применения:**

- Процесс можно применять как к новым, так и к существующим проектам
- Можно использовать независимо от других процессов
- Легко адаптировать под конкретные потребности проекта

---

### 3.2. Рефакторинг легаси кода

Этот модульный процесс описывает систематический подход к рефакторингу устаревшего кода с использованием Memory Bank System.

#### Контекст задачи

**Исходная ситуация:**

- Существующий проект с легаси кодом
- Устаревшие паттерны и подходы в коде
- Технический долг, требующий решения
- Необходимость модернизации без нарушения работы приложения

#### Шаг 1: Планирование

**Команда:** `/plan`

**Действия:**

1. **Анализ легаси кода:**

   - Выявление устаревших паттернов и подходов
   - Определение проблемных участков кода
   - Оценка рисков рефакторинга
   - Определение зависимостей между компонентами

2. **Приоритизация задач рефакторинга:**

   - Определение критических участков, требующих немедленного рефакторинга
   - Выявление участков, которые можно отложить
   - Оценка влияния рефакторинга на другие части системы

3. **Создание плана рефакторинга:**
   - Разбиение работы на этапы
   - Определение порядка рефакторинга компонентов
   - Планирование тестирования после каждого этапа
   - Оценка времени и сложности

**Результат:**

- План рефакторинга записан в `memory-bank/tasks.md`
- Приоритеты определены и задокументированы
- Риски оценены и учтены в плане

#### Шаг 2: Проектирование

**Команда:** `/creative`

**Действия:**

1. **Проектирование новых паттернов:**

   - Определение современных паттернов для замены устаревших
   - Проектирование архитектуры после рефакторинга
   - Планирование миграционной стратегии

2. **Создание схем миграции:**

   - Схемы преобразования старого кода в новый
   - Планирование промежуточных состояний (если необходимо)
   - Определение точек тестирования

3. **Документирование решений:**
   - Архитектурные решения сохраняются в `memory-bank/creative/refactoring-plan.md`
   - Паттерны миграции документируются
   - Стратегия тестирования определяется

**Результат:**

- Стратегия рефакторинга спроектирована
- Современные паттерны определены
- Готовность к валидации

#### Шаг 3: Валидация технических требований

**Команда:** Введите текст **"VAN QA"**

**Действия:**

1. **Проверка готовности к рефакторингу:**

   - Валидация текущего состояния кодовой базы
   - Проверка наличия тестов (если есть)
   - Оценка рисков рефакторинга

2. **Валидация новых зависимостей:**

   - Проверка совместимости новых библиотек с существующими
   - Валидация версий пакетов
   - Выявление потенциальных конфликтов

3. **Проверка работоспособности:**
   - Тест текущей сборки проекта
   - Валидация базовой функциональности
   - Создание точки восстановления (backup)

**Результат:**

- Безопасность рефакторинга подтверждена
- Риски оценены и задокументированы
- Готовность к внесению изменений

#### Шаг 4: Реализация

**Команда:** `/build`

**Действия:**

1. **Поэтапный рефакторинг:**

   - Рефакторинг компонентов по приоритету
   - Сохранение работоспособности приложения на каждом этапе
   - Тестирование после каждого значимого изменения

2. **Документирование изменений:**

   - Фиксация изменений в `memory-bank/activeContext.md`
   - Обновление `systemPatterns.md` с новыми паттернами
   - Отслеживание прогресса в `progress.md`

3. **Итеративный процесс:**
   - Рефакторинг компонента
   - Тестирование
   - Обновление документации
   - Переход к следующему компоненту

**Результат:**

- Код модернизирован согласно плану
- Приложение продолжает работать
- Новые паттерны внедрены и задокументированы

#### Шаг 5: Рефлексия

**Команда:** `/reflect`

**Действия:**

1. **Анализ результатов:**

   - Оценка качества рефакторинга
   - Выявление проблем, возникших в процессе
   - Анализ эффективности выбранных паттернов

2. **Документирование уроков:**
   - Извлеченные уроки сохраняются в `systemPatterns.md`
   - Рекомендации для будущего рефакторинга
   - Лучшие практики документируются

**Результат:**

- Рефакторинг проанализирован
- Накоплен опыт для будущих задач
- Улучшения задокументированы

---

### 3.3. Добавление новой функциональности

Этот модульный процесс описывает добавление новой функциональности в существующий проект с использованием Memory Bank System.

#### Контекст задачи

**Исходная ситуация:**

- Работающий проект (новый или существующий)
- Необходимость добавить новую функцию или фичу
- Требование сохранить существующую функциональность
- Необходимость документировать изменения

#### Шаг 1: Планирование

**Команда:** `/plan`

**Действия:**

1. **Анализ требований:**

   - Определение функциональности новой фичи
   - Анализ влияния на существующий код
   - Выявление зависимостей и взаимодействий
   - Оценка сложности реализации

2. **Планирование реализации:**

   - Разбиение на задачи и подзадачи
   - Определение приоритетов
   - Планирование архитектуры новой функциональности
   - Определение точек интеграции с существующим кодом

3. **Создание плана:**
   - Задачи записываются в `memory-bank/tasks.md`
   - Оценка времени и сложности в `progress.md`
   - Архитектурные требования в `systemPatterns.md`

**Результат:**

- Четкий план реализации новой функциональности
- Понимание влияния на существующий код
- Готовность к проектированию

#### Шаг 2: Проектирование

**Команда:** `/creative`

**Действия:**

1. **Проектирование архитектуры:**

   - Проектирование компонентов новой функциональности
   - Определение взаимодействия с существующим кодом
   - Планирование структуры данных
   - Проектирование API (если необходимо)

2. **Создание прототипов и схем:**

   - Схемы компонентов и их взаимодействия
   - Прототипы UI (если применимо)
   - Архитектурные решения

3. **Документирование:**
   - Решения сохраняются в `memory-bank/creative/`
   - Архитектура документируется
   - Планы интеграции фиксируются

**Результат:**

- Архитектура новой функциональности спроектирована
- Взаимодействие с существующим кодом определено
- Готовность к валидации

#### Шаг 3: Валидация технических требований

**Команда:** Введите текст **"VAN QA"**

**Действия:**

1. **Проверка зависимостей:**

   - Валидация необходимых библиотек для новой функциональности
   - Проверка совместимости с существующими зависимостями
   - Выявление потенциальных конфликтов

2. **Валидация интеграции:**

   - Проверка точек интеграции с существующим кодом
   - Валидация API и интерфейсов
   - Тест взаимодействия компонентов

3. **Проверка готовности окружения:**
   - Валидация необходимых инструментов
   - Проверка конфигурации для новой функциональности
   - Тест базовой совместимости

**Результат:**

- Техническая готовность к реализации подтверждена
- Риски интеграции оценены
- Все зависимости проверены

#### Шаг 4: Реализация

**Команда:** `/build`

**Действия:**

1. **Систематическая реализация:**

   - Выполнение задач по плану
   - Создание компонентов согласно архитектуре
   - Интеграция с существующим кодом
   - Тестирование на каждом этапе

2. **Обновление Memory Bank:**

   - `activeContext.md`: текущий фокус работы
   - `progress.md`: прогресс реализации
   - `systemPatterns.md`: новые паттерны и решения

3. **Итеративный процесс:**
   - Реализация задачи
   - Тестирование
   - Обновление документации
   - Переход к следующей задаче

**Результат:**

- Новая функциональность реализована
- Интегрирована с существующим кодом
- Протестирована и задокументирована

#### Шаг 5: Рефлексия

**Команда:** `/reflect`

**Действия:**

1. **Анализ реализации:**

   - Оценка качества реализации
   - Выявление проблем и улучшений
   - Анализ соответствия изначальному плану

2. **Документирование:**
   - Уроки сохраняются в `systemPatterns.md`
   - Рекомендации для будущих фич
   - Лучшие практики документируются

**Результат:**

- Реализация проанализирована
- Опыт накоплен для будущих задач
- Улучшения задокументированы

---

## Комбинированные сценарии

Модульные процессы можно комбинировать и применять в различных последовательностях в зависимости от потребностей проекта. Ниже приведены примеры комбинированных сценариев.

### Сценарий 1: Новый проект → Добавление локализации

**Последовательность команд:**

1. **Инициализация нового проекта** (раздел 2.1)

   ```
   /van Создать TO-DO приложение на React 19 с TypeScript и Tailwind CSS
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

2. **Добавление мультиязычности** (раздел 3.1)

   ```
   /van Добавить мультиязычность (i18n) в TO-DO приложение
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

**Особенности:**

- Компоненты создаются сразу с учетом необходимости локализации
- Можно планировать структуру переводов заранее
- Проще интегрировать локализацию в новые компоненты
- VAN QA на каждом этапе гарантирует техническую готовность

### Сценарий 2: Существующий проект → Рефакторинг → Локализация

**Последовательность команд:**

1. **Интеграция в существующий проект** (раздел 2.2)

   ```
   /van Интегрировать Memory Bank System в существующее TO-DO приложение
   /plan
   /reflect
   /plan
   ```

2. **Рефакторинг легаси кода** (раздел 3.2)

   ```
   /van Рефакторинг легаси кода в TO-DO приложении
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

3. **Добавление мультиязычности** (раздел 3.1)

   ```
   /van Добавить мультиязычность (i18n) в TO-DO приложение
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

**Особенности:**

- Рефакторинг упрощает последующую локализацию
- Можно совместить рефакторинг с добавлением локализации
- Постепенное улучшение проекта
- VAN QA проверяет безопасность каждого этапа рефакторинга

### Сценарий 3: Существующий проект → Локализация → Новая функциональность

**Последовательность команд:**

1. **Интеграция в существующий проект** (раздел 2.2)

   ```
   /van Интегрировать Memory Bank System в существующее TO-DO приложение
   /plan
   /reflect
   /plan
   ```

2. **Добавление мультиязычности** (раздел 3.1)

   ```
   /van Добавить мультиязычность (i18n) в TO-DO приложение
   /plan
   /creative
   /build
   /reflect
   /archive
   ```

3. **Добавление новой функциональности** (раздел 3.3)

   ```
   /van Добавить функцию фильтрации задач по статусу
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

**Особенности:**

- Новая функциональность сразу поддерживает несколько языков
- Единый подход к локализации во всем проекте
- Легче поддерживать консистентность
- VAN QA гарантирует готовность окружения на каждом этапе

### Сценарий 4: Новый проект → Новая функциональность → Локализация

**Последовательность команд:**

1. **Инициализация нового проекта** (раздел 2.1)

   ```
   /van Создать TO-DO приложение на React 19 с TypeScript и Tailwind CSS
   /plan
   /creative
   /build
   /reflect
   /archive
   ```

2. **Добавление новой функциональности** (раздел 3.3)

   ```
   /van Добавить функцию фильтрации и сортировки задач
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

3. **Добавление мультиязычности** (раздел 3.1)

   ```
   /van Добавить мультиязычность (i18n) в TO-DO приложение
   /plan
   /creative
   VAN QA
   /build
   /reflect
   /archive
   ```

**Особенности:**

- Можно сначала реализовать всю функциональность
- Затем локализовать все сразу
- Единый процесс локализации для всего проекта
- VAN QA на каждом этапе предотвращает технические проблемы

### Рекомендации по комбинированию процессов

**Приоритеты:**

- Сначала рефакторинг, затем локализация — упрощает работу
- Локализация перед новой функциональностью — новая функциональность сразу поддерживает несколько языков
- Документирование между этапами — помогает сохранять контекст
- **VAN QA на каждом критическом этапе** — предотвращает технические проблемы

**Гибкость:**

- Процессы можно применять в любом порядке
- Можно пропускать ненужные этапы (кроме VAN QA для значительных изменений)
- Можно возвращаться к предыдущим этапам при необходимости
- VAN QA можно запускать повторно после исправления проблем

---

## Рекомендации и лучшие практики

### Когда использовать каждый процесс

#### Базовые сценарии инициализации

**Инициализация нового проекта (2.1):**

- Используйте при создании проекта с нуля
- Когда используете пустой бойлерплейт
- Когда хотите сразу начать работу с Memory Bank

**Интеграция в существующий проект (2.2):**

- Используйте для проектов с легаси кодом
- Когда нужно добавить Memory Bank в работающий проект
- Когда требуется структурировать существующую документацию

#### Модульные процессы

**Добавление мультиязычности (3.1):**

- Когда нужно добавить поддержку нескольких языков
- Независимо от того, новый проект или существующий
- Когда все тексты хардкодные и требуют локализации

**Рефакторинг легаси кода (3.2):**

- Когда код содержит устаревшие паттерны
- Когда накопился технический долг
- Когда нужно модернизировать код без нарушения работы

**Добавление новой функциональности (3.3):**

- Когда нужно расширить существующий проект
- Когда добавляются новые фичи
- Когда требуется документировать изменения

### Лучшие практики работы с Memory Bank

#### Регулярное обновление файлов

- **`activeContext.md`**: обновляйте при каждом изменении фокуса работы
- **`progress.md`**: регулярно обновляйте прогресс выполнения задач
- **`systemPatterns.md`**: добавляйте новые паттерны по мере их использования

#### Структурирование задач

- Разбивайте большие задачи на подзадачи
- Определяйте приоритеты и зависимости
- Регулярно пересматривайте и обновляйте задачи

#### Документирование решений

- Сохраняйте архитектурные решения в `creative/`
- Документируйте причины выбора тех или иных подходов
- Фиксируйте извлеченные уроки в `systemPatterns.md`

#### Использование команд

**Правильный формат команд:**

- **`/van [описание задачи]`** — всегда с описанием задачи

  - Пример: `/van Добавить аутентификацию пользователей`
  - Пример: `/van Рефакторинг компонента TodoList`

- **Остальные команды** — без параметров
  - `/plan` — планирование текущей задачи
  - `/creative` — проектирование для текущей задачи
  - `/build` — реализация текущей задачи
  - `/reflect` — рефлексия над выполненной работой
  - `/archive` — архивация завершенной задачи

**Рекомендации:**

- Используйте команды Memory Bank последовательно
- Не пропускайте этап рефлексии — он помогает улучшить процесс
- Адаптируйте процесс под свои потребности
- Каждая новая задача начинается с `/van [описание]`

### Работа с существующим кодом

#### Постепенные изменения

- Вносите изменения постепенно, не нарушая работу приложения
- Тестируйте после каждого значимого изменения
- Документируйте изменения в Memory Bank

#### Сохранение контекста

- Документируйте особенности существующего кода
- Сохраняйте понимание причин текущих решений
- Используйте Memory Bank для передачи контекста между сессиями

### Оптимизация процесса

#### Адаптация под проект

- Не все процессы могут быть нужны для каждого проекта
- Выбирайте только необходимые модульные процессы
- Адаптируйте правила Memory Bank под свои потребности

#### Итеративный подход

- Работайте итеративно, небольшими шагами
- Регулярно пересматривайте план и приоритеты
- Используйте рефлексию для улучшения процесса

### Советы по эффективности

#### Планирование

- Тратьте время на качественное планирование — это сэкономит время в реализации
- Используйте команду `/plan` для структурирования работы
- Регулярно обновляйте план по мере появления новой информации
- После `/van [описание]` всегда выполняйте `/plan` для создания структурированного плана

#### Использование Context7

- **Указывайте Context7 в команде `/van`** — это обеспечит использование актуальной документации на всех этапах
- Пример: `/van [описание задачи]. Используй Context7 MCP-сервер.`
- Context7 автоматически применяется во всех последующих командах (`/plan`, `/creative`, `/build`)
- Особенно полезно для проектов с современными библиотеками и фреймворками
- Если Context7 не настроен, ИИ будет использовать базовые знания

#### Техническая валидация

- **Всегда используйте VAN QA** перед переходом к реализации
- VAN QA экономит время, выявляя проблемы до начала кодирования
- При неудачной валидации исправьте проблемы и запустите VAN QA повторно
- Для существующих проектов рекомендуется VAN QA перед значительными изменениями
- Не пропускайте VAN QA — система заблокирует доступ к `/build` без успешной валидации

#### Управление контекстом чатов

- **Создавайте новый чат** для каждой команды Memory Bank (`/van`, `/plan`, `/creative`, `/build`, `/reflect`, `/archive`)
- **Исключение:** VAN QA выполняется **в том же чате**, что и `/creative`
- Это обеспечивает чистый контекст для каждой фазы и фокусировку на текущей задаче
- Memory Bank сохраняет всю необходимую информацию между чатами через файловую систему
- При неудачной VAN QA оставайтесь в том же чате для повторной валидации

#### Документирование

- Документируйте по ходу работы, а не в конце
- Используйте Memory Bank как живой документ проекта
- Регулярно обновляйте файлы Memory Bank

#### Рефлексия

- Не пропускайте этап рефлексии — он помогает улучшить процесс
- Анализируйте не только результаты, но и сам процесс работы
- Используйте извлеченные уроки для улучшения будущей работы

---
