# Что такое `код в bare React Native проекте`?

## Вопрос:

> [!NOTE]
> Что такое `код в bare React Native проекте`?

## Ответ:

> [!TIP]
> Когда говорят о "коде в "bare" React Native проекте", имеют в виду **традиционную структуру проекта React Native, которая не использует Managed Workflow Expo**. Это подход, при котором у вас есть **прямой доступ и полный контроль над нативными проектами для iOS и Android**, которые формируют ваше мобильное приложение.

Давайте разберем, что это означает:

**1. Структура папок:**

В отличие от проекта Expo, где нативные файлы скрыты и управляются Expo SDK, "bare" React Native проект, созданный с помощью `npx react-native init <ProjectName>`, будет иметь следующую структуру:

```
YourProjectName/
├── android/          // Нативный проект для Android (Java/Kotlin, Gradle)
├── ios/              // Нативный проект для iOS (Objective-C/Swift, Xcode, CocoaPods)
├── node_modules/     // Установленные JavaScript-зависимости
├── App.js            // Ваш основной JavaScript/TypeScript код приложения
├── package.json      // Конфигурация проекта, зависимости
├── index.js          // Точка входа для React Native
├── .gitignore
└── ... другие файлы конфигурации
```

**2. Нативный код:**

- **`android/` папка:** Содержит все, что относится к сборке Android-приложения. Здесь находятся:
  - Java/Kotlin файлы (например, `MainActivity.java` или `MainActivity.kt`, `MainApplication.java` или `MainApplication.kt`). Это точка входа для нативного Android-приложения.
  - Файлы `build.gradle` (на уровне проекта и на уровне модуля `app`), которые управляют сборкой Android-приложения, зависимостями (включая зависимости для React Native и любых нативных модулей).
  - Файл `AndroidManifest.xml`, который описывает компоненты приложения (активности, сервисы), запрашивает разрешения и т.д.
  - Ресурсы Android (файлы разметки XML, изображения и т.д.).
- **`ios/` папка:** Содержит все, что относится к сборке iOS-приложения. Здесь находятся:
  - Objective-C/Swift файлы (например, `AppDelegate.m` или `AppDelegate.swift`, `main.m`). Это точка входа для нативного iOS-приложения.
  - Файл `Info.plist`, который содержит метаданные приложения (имя, версия, разрешения, поддерживаемые ориентации и т.д.).
  - Файл `.xcodeproj` (проект Xcode) и `Podfile` (для управления зависимостями через CocoaPods).
  - Ресурсы iOS (изображения, шрифты и т.д.).

**3. Управление зависимостями и нативными модулями:**

- В "bare" React Native проекте, если вы хотите использовать сторонние библиотеки, которые имеют нативный код (например, `react-native-maps` для карт, `react-native-camera` для камеры), вам, возможно, придется **вручную связывать** эти нативные модули с вашими нативными проектами (Android и iOS).
  - Для iOS это часто включает запуск `npx pod-install ios` после установки библиотеки и иногда ручные изменения в Xcode.
  - Для Android это может потребовать добавления строк кода в `build.gradle` или `MainActivity.java`/`MainApplication.java`.
- Некоторые современные библиотеки React Native используют **автоматическую линковку** (autolinking), что упрощает этот процесс, но все равно есть ситуации, когда требуется ручная настройка.

**4. Процесс сборки:**

- Сборка "bare" React Native приложения осуществляется с помощью нативных инструментов:
  - Для Android: `Android Studio` и `Gradle` (команды `npx react-native run-android`).
  - Для iOS: `Xcode` и `CocoaPods` (команды `npx react-native run-ios`).
- Это означает, что вам нужно иметь установленные и настроенные SDK для Android и iOS, а также соответствующие IDE.

### **Почему это называют "bare" (голый/чистый):**

Название "bare" указывает на то, что это **базовый, минимальный набор файлов, необходимый для запуска React Native приложения, без дополнительных абстракций и инструментов, предоставляемых Expo (в его управляемом режиме)**. Вы получаете прямой доступ к нативным проектам и можете модифицировать их любым способом.

**В итоге, "код в "bare" React Native проекте" - это совокупность вашего JavaScript/TypeScript кода, нативного кода для iOS и Android, файлов конфигурации сборки, а также сторонних нативных библиотек, которые вместе формируют полноценное мобильное приложение.** Этот подход дает максимальную гибкость и контроль, но требует от разработчика большего понимания особенностей каждой нативной платформы.
