# **Expo EAS (Expo Application Services) добавляет свой собственный код и конфигурацию в собираемые нативные приложения**. Однако важно понимать, _какой_ код и _почему_.

Это не "лишний" или нежелательный код в смысле загрязнения вашего приложения, а скорее **инфраструктурный код и конфигурация**, которые позволяют Expo предоставлять свои удобные функции и сервисы.

## **Что именно добавляет Expo EAS Build:**

1.  **Expo SDK:** Когда вы используете библиотеки из Expo SDK (например, `expo-camera`, `expo-location` и т.д.), их нативный код (Objective-C/Swift для iOS, Java/Kotlin для Android) включается в финальную сборку. Это происходит аналогично тому, как любая другая нативная библиотека (`react-native-maps`, `react-native-notifications`) добавляет свой код в "bare" React Native проект. Преимущество Expo в том, что все эти библиотеки уже предустановлены и оптимизированы для совместной работы.

2.  **Конфигурационные плагины (Config Plugins):** Expo использует систему конфигурационных плагинов. Эти плагины модифицируют нативные файлы проекта (например, `Info.plist` для iOS, `AndroidManifest.xml` для Android, `build.gradle` и т.д.) на основе настроек, указанных в вашем файле `app.json` или `app.config.js`. Это автоматизирует процесс настройки нативных проектов, который в "bare" React Native пришлось бы делать вручную.

    - Например, если вы указываете разрешение на использование камеры в `app.json`, Expo Config Plugin автоматически добавит соответствующую строку в `AndroidManifest.xml` Android и `Info.plist` iOS.

3.  **"Bare" проект на основе шаблона Expo:** При сборке с EAS Build (особенно если вы используете "managed" workflow), Expo CLI генерирует временный "bare" React Native проект на основе шаблона, соответствующего вашей версии Expo SDK. В этот проект включаются:

    - Стандартные нативные файлы, необходимые для запуска любого React Native приложения.
    - Собственный нативный код Expo, который обеспечивает работу Expo SDK и его инструментов (например, `expo-updates` для OTA-обновлений, если вы его используете).
    - Автоматическая линковка всех используемых нативных модулей (как из Expo SDK, так и сторонних, которые поддерживают автолинковку).

4.  **Код для Expo Development Client (при создании dev-сборок):** Если вы создаете "development build" (сборку для разработки), в неё будет включен дополнительный код Expo Development Client. Этот код позволяет загружать ваш JavaScript-бандл с локального сервера разработки, использовать отладку и другие функции для разработчиков. Он не включается в production-сборки.

5.  **EAS Build Environment:** Сами EAS Build servers используют контейнеризированную среду (например, Docker), где установлены все необходимые инструменты (Xcode, Android SDK, Node.js, Watchman и т.д.). Ваше приложение собирается в этой контролируемой среде.

## **Почему это делается (и почему это полезно):**

Основная цель Expo EAS — **упростить и автоматизировать процесс нативной сборки**, который в "bare" React Native может быть очень трудоемким и требовать глубоких знаний нативных платформ.

- **Консистентность:** Expo гарантирует, что нативные зависимости и конфигурации всегда будут согласованы с используемой версией Expo SDK.
- **Автоматизация:** Вам не нужно вручную редактировать нативные файлы проекта или управлять сложными настройками сборки.
- **OTA-обновления:** Интеграция `expo-updates` позволяет отправлять JS-обновления без пересборки всего нативного приложения.
- **Поддержка кастомного нативного кода:** Современный Expo позволяет добавлять свой собственный нативный код (через Expo Modules API или обычные нативные модули) в managed workflow, при этом сохраняя большинство преимуществ EAS Build.

## **Вывод:**

Expo EAS добавляет свой код, но это не просто "дополнительный" код. Это **неотъемлемая часть фреймворка Expo**, которая позволяет ему предоставлять свои мощные функции, абстрагировать разработчика от сложностей нативной среды и значительно ускорять процесс разработки и деплоя React Native приложений. Для большинства проектов, даже больших, это является преимуществом, а не недостатком, поскольку уменьшает объем ручной работы и вероятность ошибок.
